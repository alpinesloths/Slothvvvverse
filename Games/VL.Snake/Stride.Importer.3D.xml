<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Stride.Importer.3D</name>
    </assembly>
    <members>
        <member name="T:Stride.Importer.ThreeD.aiPostProcessSteps">
            <summary>
            Extracted from assimp/postprocess.h, Silk does not yet provide all of those
            </summary>
        </member>
        <member name="F:Stride.Importer.ThreeD.aiPostProcessSteps.aiProcess_CalcTangentSpace">
            <summary>
            Calculates the tangents and bitangents for the imported meshes./// Does nothing if a mesh does not have normals. You might want this post
            processing step to be executed if you plan to use tangent space calculations
            such as normal mapping  applied to the meshes. There's an importer property,
            <tt>#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</tt>, which allows you to specify
            a maximum smoothing angle for the algorithm. However, usually you'll
            want to leave it at the default value.
            </summary>
        </member>
        <member name="F:Stride.Importer.ThreeD.aiPostProcessSteps.aiProcess_JoinIdenticalVertices">
            <summary>
            Identifies and joins identical vertex data sets within all
             imported meshes./// After this step is run, each mesh contains unique vertices,
            so a vertex may be used by multiple faces. You usually want
            to use this post processing step. If your application deals with
            indexed geometry, this step is compulsory or you'll just waste rendering
            time. <b>If this flag is not specified</b>, no vertices are referenced by
            more than one face and <b>no index buffer is required</b> for rendering.
            Unless the importer (like ply) had to split vertices. Then you need one regardless.
            </summary>
        </member>
        <member name="F:Stride.Importer.ThreeD.aiPostProcessSteps.aiProcess_MakeLeftHanded">
            <summary>
            Converts all the imported data to a left-handed coordinate space./// By default the data is returned in a right-handed coordinate space (which
            OpenGL prefers). In this space, +X points to the right,
            +Z points towards the viewer, and +Y points upwards. In the DirectX
            coordinate space +X points to the right, +Y points upwards, and +Z points
            away from the viewer./// You'll probably want to consider this flag if you use Direct3D for
            rendering. The #aiProcess_ConvertToLeftHanded flag supersedes this
            setting and bundles all conversions typically required for D3D-based
            applications.
            </summary>
        </member>
        <member name="F:Stride.Importer.ThreeD.aiPostProcessSteps.aiProcess_Triangulate">
            <summary>
            Triangulates all faces of all meshes./// By default the imported mesh data might contain faces with more than 3
            indices. For rendering you'll usually want all faces to be triangles.
            This post processing step splits up faces with more than 3 indices into
            triangles. Line and point primitives are *not* modified! If you want
            'triangles only' with no other kinds of primitives, try the following
            solution:
            <ul>
            <li>Specify both #aiProcess_Triangulate and #aiProcess_SortByPType </li>
            <li>Ignore all point and line meshes when you process assimp's output</li>
            </ul>
            </summary>
        </member>
        <member name="F:Stride.Importer.ThreeD.aiPostProcessSteps.aiProcess_RemoveComponent">
            <summary>
            Removes some parts of the data structure (animations, materials,
             light sources, cameras, textures, vertex components)./// The  components to be removed are specified in a separate
            importer property, <tt>#AI_CONFIG_PP_RVC_FLAGS</tt>. This is quite useful
            if you don't need all parts of the output structure. Vertex colors
            are rarely used today for example... Calling this step to remove unneeded
            data from the pipeline as early as possible results in increased
            performance and a more optimized output data structure.
            This step is also useful if you want to force Assimp to recompute
            normals or tangents. The corresponding steps don't recompute them if
            they're already there (loaded from the source asset). By using this
            step you can make sure they are NOT there./// This flag is a poor one, mainly because its purpose is usually
            misunderstood. Consider the following case: a 3D model has been exported
            from a CAD app, and it has per-face vertex colors. Vertex positions can't be
            shared, thus the #aiProcess_JoinIdenticalVertices step fails to
            optimize the data because of these nasty little vertex colors.
            Most apps don't even process them, so it's all for nothing. By using
            this step, unneeded components are excluded as early as possible
            thus opening more room for internal optimizations.
            </summary>
        </member>
        <member name="F:Stride.Importer.ThreeD.aiPostProcessSteps.aiProcess_GenNormals">
            <summary>
            Generates normals for all faces of all meshes./// This is ignored if normals are already there at the time this flag
            is evaluated. Model importers try to load them from the source file, so
            they're usually already there. Face normals are shared between all points
            of a single face, so a single point can have multiple normals, which
            forces the library to duplicate vertices in some cases.
            #aiProcess_JoinIdenticalVertices is *senseless* then./// This flag may not be specified together with #aiProcess_GenSmoothNormals.
            </summary>
        </member>
        <member name="F:Stride.Importer.ThreeD.aiPostProcessSteps.aiProcess_GenSmoothNormals">
            <summary>
            Generates smooth normals for all vertices in the mesh./// This is ignored if normals are already there at the time this flag
            is evaluated. Model importers try to load them from the source file, so
            they're usually already there./// This flag may not be specified together with
            #aiProcess_GenNormals. There's a importer property,
            <tt>#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</tt> which allows you to specify
            an angle maximum for the normal smoothing algorithm. Normals exceeding
            this limit are not smoothed, resulting in a 'hard' seam between two faces.
            Using a decent angle here (e.g. 80 degrees) results in very good visual
            appearance.
            </summary>
        </member>
        <member name="F:Stride.Importer.ThreeD.aiPostProcessSteps.aiProcess_SplitLargeMeshes">
            <summary>
            Splits large meshes into smaller sub-meshes./// This is quite useful for real-time rendering, where the number of triangles
            which can be maximally processed in a single draw-call is limited
            by the video driver/hardware. The maximum vertex buffer is usually limited
            too. Both requirements can be met with this step: you may specify both a
            triangle and vertex limit for a single mesh./// The split limits can (and should!) be set through the
            <tt>#AI_CONFIG_PP_SLM_VERTEX_LIMIT</tt> and <tt>#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</tt>
            importer properties. The default values are <tt>#AI_SLM_DEFAULT_MAX_VERTICES</tt> and
            <tt>#AI_SLM_DEFAULT_MAX_TRIANGLES</tt>./// Note that splitting is generally a time-consuming task, but only if there's
            something to split. The use of this step is recommended for most users.
            </summary>
        </member>
        <member name="F:Stride.Importer.ThreeD.aiPostProcessSteps.aiProcess_PreTransformVertices">
            <summary>
            Removes the node graph and pre-transforms all vertices with
            the local transformation matrices of their nodes./// If the resulting scene can be reduced to a single mesh, with a single
            material, no lights, and no cameras, then the output scene will contain
            only a root node (with no children) that references the single mesh.
            Otherwise, the output scene will be reduced to a root node with a single
            level of child nodes, each one referencing one mesh, and each mesh
            referencing one material./// In either case, for rendering, you can
            simply render all meshes in order - you don't need to pay
            attention to local transformations and the node hierarchy.
            Animations are removed during this step.
            This step is intended for applications without a scenegraph.
            The step CAN cause some problems: if e.g. a mesh of the asset
            contains normals and another, using the same material index, does not,
            they will be brought together, but the first meshes's part of
            the normal list is zeroed. However, these artifacts are rare.
            @note The <tt>#AI_CONFIG_PP_PTV_NORMALIZE</tt> configuration property
            can be set to normalize the scene's spatial dimension to the -1...1
            range.
            </summary>
        </member>
        <member name="F:Stride.Importer.ThreeD.aiPostProcessSteps.aiProcess_LimitBoneWeights">
            <summary>
            Limits the number of bones simultaneously affecting a single vertex to a maximum value./// If any vertex is affected by more than the maximum number of bones, the least
            important vertex weights are removed and the remaining vertex weights are
            renormalized so that the weights still sum up to 1.
            The default bone weight limit is 4 (defined as <tt>#AI_LMW_MAX_WEIGHTS</tt> in
            config.h), but you can use the <tt>#AI_CONFIG_PP_LBW_MAX_WEIGHTS</tt> importer
            property to supply your own limit to the post processing step./// If you intend to perform the skinning in hardware, this post processing
            step might be of interest to you.
            </summary>
        </member>
        <member name="F:Stride.Importer.ThreeD.aiPostProcessSteps.aiProcess_ValidateDataStructure">
            <summary>
            Validates the imported scene data structure.
            This makes sure that all indices are valid, all animations and
            bones are linked correctly, all material references are correct .. etc./// It is recommended that you capture Assimp's log output if you use this flag,
            so you can easily find out what's wrong if a file fails the
            validation. The validator is quite strict and will find *all*
            inconsistencies in the data structure... It is recommended that plugin
            developers use it to debug their loaders. There are two types of
            validation failures:
            <ul>
            <li>Error: There's something wrong with the imported data. Further
              postprocessing is not possible and the data is not usable at all.
              The import fails. #Importer::GetErrorString() or #aiGetErrorString()
              carry the error message around.</li>
            <li>Warning: There are some minor issues (e.g. 1000000 animation
              keyframes with the same time), but further postprocessing and use
              of the data structure is still safe. Warning details are written
              to the log file, <tt>#AI_SCENE_FLAGS_VALIDATION_WARNING</tt> is set
              in #aiScene::mFlags</li>
            </ul>/// This post-processing step is not time-consuming. Its use is not
            compulsory, but recommended.
            </summary>
        </member>
        <member name="F:Stride.Importer.ThreeD.aiPostProcessSteps.aiProcess_ImproveCacheLocality">
            <summary>
            Reorders triangles for better vertex cache locality./// The step tries to improve the ACMR (average post-transform vertex cache
            miss ratio) for all meshes. The implementation runs in O(n) and is
            roughly based on the 'tipsify' algorithm (see <a href="
            http://www.cs.princeton.edu/gfx/pubs/Sander_2007_%3ETR/tipsy.pdf">this
            paper</a>)./// If you intend to render huge models in hardware, this step might
            be of interest to you. The <tt>#AI_CONFIG_PP_ICL_PTCACHE_SIZE</tt>
            importer property can be used to fine-tune the cache optimization.
            </summary>
        </member>
        <member name="F:Stride.Importer.ThreeD.aiPostProcessSteps.aiProcess_RemoveRedundantMaterials">
            <summary>
            Searches for redundant/unreferenced materials and removes them./// This is especially useful in combination with the
            #aiProcess_PreTransformVertices and #aiProcess_OptimizeMeshes flags.
            Both join small meshes with equal characteristics, but they can't do
            their work if two meshes have different materials. Because several
            material settings are lost during Assimp's import filters,
            (and because many exporters don't check for redundant materials), huge
            models often have materials which are are defined several times with
            exactly the same settings./// Several material settings not contributing to the final appearance of
            a surface are ignored in all comparisons (e.g. the material name).
            So, if you're passing additional information through the
            content pipeline (probably using *magic* material names), don't
            specify this flag. Alternatively take a look at the
            <tt>#AI_CONFIG_PP_RRM_EXCLUDE_LIST</tt> importer property.
            </summary>
        </member>
        <member name="F:Stride.Importer.ThreeD.aiPostProcessSteps.aiProcess_FixInfacingNormals">
            <summary>
            This step tries to determine which meshes have normal vectors
            that are facing inwards and inverts them./// The algorithm is simple but effective:
            the bounding box of all vertices + their normals is compared against
            the volume of the bounding box of all vertices without their normals.
            This works well for most objects, problems might occur with planar
            surfaces. However, the step tries to filter such cases.
            The step inverts all in-facing normals. Generally it is recommended
            to enable this step, although the result is not always correct.
            </summary>
        </member>
        <member name="F:Stride.Importer.ThreeD.aiPostProcessSteps.aiProcess_PopulateArmatureData">
            <summary>
            This step generically populates aiBone->mArmature and aiBone->mNode generically
            The point of these is it saves you later having to calculate these elements
            This is useful when handling rest information or skin information
            If you have multiple armatures on your models we strongly recommend enabling this
            Instead of writing your own multi-root, multi-armature lookups we have done the
            hard work for you :)
            </summary>
        </member>
        <member name="F:Stride.Importer.ThreeD.aiPostProcessSteps.aiProcess_SortByPType">
            <summary>
            This step splits meshes with more than one primitive type in
             homogeneous sub-meshes.///  The step is executed after the triangulation step. After the step
             returns, just one bit is set in aiMesh::mPrimitiveTypes. This is
             especially useful for real-time rendering where point and line
             primitives are often ignored or rendered separately.
             You can use the <tt>#AI_CONFIG_PP_SBP_REMOVE</tt> importer property to
             specify which primitive types you need. This can be used to easily
             exclude lines and points, which are rarely used, from the import.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Stride.Importer.ThreeD.aiPostProcessSteps.aiProcess_FindDegenerates" -->
        <!-- Badly formed XML comment ignored for member "F:Stride.Importer.ThreeD.aiPostProcessSteps.aiProcess_FindInvalidData" -->
        <member name="F:Stride.Importer.ThreeD.aiPostProcessSteps.aiProcess_GenUVCoords">
            <summary>
            This step converts non-UV mappings (such as spherical or
             cylindrical mapping) to proper texture coordinate channels./// Most applications will support UV mapping only, so you will
            probably want to specify this step in every case. Note that Assimp is not
            always able to match the original mapping implementation of the
            3D app which produced a model perfectly. It's always better to let the
            modelling app compute the UV channels - 3ds max, Maya, Blender,
            LightWave, and Modo do this for example./// @note If this step is not requested, you'll need to process the
            <tt>#AI_MATKEY_MAPPING</tt> material property in order to display all assets
            properly.
            </summary>
        </member>
        <member name="F:Stride.Importer.ThreeD.aiPostProcessSteps.aiProcess_TransformUVCoords">
            <summary>
            This step applies per-texture UV transformations and bakes
             them into stand-alone vtexture coordinate channels./// UV transformations are specified per-texture - see the
            <tt>#AI_MATKEY_UVTRANSFORM</tt> material key for more information.
            This step processes all textures with
            transformed input UV coordinates and generates a new (pre-transformed) UV channel
            which replaces the old channel. Most applications won't support UV
            transformations, so you will probably want to specify this step./// @note UV transformations are usually implemented in real-time apps by
            transforming texture coordinates at vertex shader stage with a 3x3
            (homogeneous) transformation matrix.
            </summary>
        </member>
        <member name="F:Stride.Importer.ThreeD.aiPostProcessSteps.aiProcess_FindInstances">
            <summary>
            This step searches for duplicate meshes and replaces them
             with references to the first mesh.///  This step takes a while, so don't use it if speed is a concern.
             Its main purpose is to workaround the fact that many export
             file formats don't support instanced meshes, so exporters need to
             duplicate meshes. This step removes the duplicates again. Please
             note that Assimp does not currently support per-node material
             assignment to meshes, which means that identical meshes with
             different materials are currently *not* joined, although this is
             planned for future versions.
            </summary>
        </member>
        <member name="F:Stride.Importer.ThreeD.aiPostProcessSteps.aiProcess_OptimizeMeshes">
            <summary>
            A post-processing step to reduce the number of meshes.///  This will, in fact, reduce the number of draw calls.///  This is a very effective optimization and is recommended to be used
             together with #aiProcess_OptimizeGraph, if possible. The flag is fully
             compatible with both #aiProcess_SplitLargeMeshes and #aiProcess_SortByPType.
            </summary>
        </member>
        <member name="F:Stride.Importer.ThreeD.aiPostProcessSteps.aiProcess_OptimizeGraph">
            <summary>
            A post-processing step to optimize the scene hierarchy.///  Nodes without animations, bones, lights or cameras assigned are
             collapsed and joined.///  Node names can be lost during this step. If you use special 'tag nodes'
             to pass additional information through your content pipeline, use the
             <tt>#AI_CONFIG_PP_OG_EXCLUDE_LIST</tt> importer property to specify a
             list of node names you want to be kept. Nodes matching one of the names
             in this list won't be touched or modified.///  Use this flag with caution. Most simple files will be collapsed to a
             single node, so complex hierarchies are usually completely lost. This is not
             useful for editor environments, but probably a very effective
             optimization if you just want to get the model data, convert it to your
             own format, and render it as fast as possible.///  This flag is designed to be used with #aiProcess_OptimizeMeshes for best
             results.///  @note 'Crappy' scenes with thousands of extremely small meshes packed
             in deeply nested nodes exist for almost all file formats.
             #aiProcess_OptimizeMeshes in combination with #aiProcess_OptimizeGraph
             usually fixes them all and makes them renderable.
            </summary>
        </member>
        <member name="F:Stride.Importer.ThreeD.aiPostProcessSteps.aiProcess_FlipUVs">
            <summary>
            This step flips all UV coordinates along the y-axis and adjusts
            material settings and bitangents accordingly./// <b>Output UV coordinate system:</b>
            @code
            0y|0y ---------- 1x|0y
            |                 |
            |                 |
            |                 |
            0x|1y ---------- 1x|1y
            @endcode/// You'll probably want to consider this flag if you use Direct3D for
            rendering. The #aiProcess_ConvertToLeftHanded flag supersedes this
            setting and bundles all conversions typically required for D3D-based
            applications.
            </summary>
        </member>
        <member name="F:Stride.Importer.ThreeD.aiPostProcessSteps.aiProcess_FlipWindingOrder">
            <summary>
            This step adjusts the output face winding order to be CW./// The default face winding order is counter clockwise (CCW)./// <b>Output face order:</b>
            @code
                  x2///                         x0
             x1
            @endcode
            </summary>
        </member>
        <member name="F:Stride.Importer.ThreeD.aiPostProcessSteps.aiProcess_SplitByBoneCount">
            <summary>
            This step splits meshes with many bones into sub-meshes so that each
            sub-mesh has fewer or as many bones as a given limit.
            </summary>
        </member>
        <member name="F:Stride.Importer.ThreeD.aiPostProcessSteps.aiProcess_Debone">
            <summary>
            This step removes bones losslessly or according to some threshold.///  In some cases (i.e. formats that require it) exporters are forced to
             assign dummy bone weights to otherwise static meshes assigned to
             animated meshes. Full, weight-based skinning is expensive while
             animating nodes is extremely cheap, so this step is offered to clean up
             the data in that regard.///  Use <tt>#AI_CONFIG_PP_DB_THRESHOLD</tt> to control this.
             Use <tt>#AI_CONFIG_PP_DB_ALL_OR_NONE</tt> if you want bones removed if and
             only if all bones within the scene qualify for removal.
            </summary>
        </member>
        <member name="F:Stride.Importer.ThreeD.aiPostProcessSteps.aiProcess_GlobalScale">
            <summary>
            This step will perform a global scale of the model.///  Some importers are providing a mechanism to define a scaling unit for the
             model. This post processing step can be used to do so. You need to get the
             global scaling from your importer settings like in FBX. Use the flag
             AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY from the global property table to configure this.///  Use <tt>#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</tt> to setup the global scaling factor.
            </summary>
        </member>
        <member name="F:Stride.Importer.ThreeD.aiPostProcessSteps.aiProcess_EmbedTextures">
            <summary>
            A postprocessing step to embed of textures.///  This will remove external data dependencies for textures.
             If a texture's file does not exist at the specified path
             (due, for instance, to an absolute path generated on another system),
             it will check if a file with the same name exists at the root folder
             of the imported model. And if so, it uses that.
            </summary>
        </member>
        <member name="F:Stride.Importer.ThreeD.aiPostProcessSteps.aiProcess_DropNormals">
            <summary>
            Drops normals for all faces of all meshes./// This is ignored if no normals are present.
            Face normals are shared between all points of a single face,
            so a single point can have multiple normals, which
            forces the library to duplicate vertices in some cases.
            #aiProcess_JoinIdenticalVertices is *senseless* then.
            This process gives sense back to aiProcess_JoinIdenticalVertices
            </summary>
        </member>
        <member name="F:Stride.Importer.ThreeD.aiPostProcessSteps.aiProcess_GenBoundingBoxes">
            <summary>
            </summary>
        </member>
        <member name="T:Stride.Importer.ThreeD.Material.Flags">
            <summary>
            Enumeration of the new Assimp's flags.
            </summary>
        </member>
        <member name="T:Stride.Importer.ThreeD.Material.MappingMode">
            <summary>
            Enumeration of the different mapping modes in the new Assimp's material stack.
            </summary>
        </member>
        <member name="F:Stride.Importer.ThreeD.Material.Materials.ConvertAssimpStackOperationCppToCs">
            <summary>
            Converts an Assimp's material stack operation From c++ to c#.
            </summary>
        </member>
        <member name="F:Stride.Importer.ThreeD.Material.Materials.ConvertAssimpStackTypeCppToCs">
            <summary>
            Converts an Assimp's material stack node type From c++ to c#.
            </summary>
        </member>
        <member name="T:Stride.Importer.ThreeD.Material.MaterialStack">
            <summary>
            Class representing the new Assimp's material stack in c#.
            </summary>
        </member>
        <member name="M:Stride.Importer.ThreeD.Material.MaterialStack.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Stride.Importer.ThreeD.Material.MaterialStack"/> class.
            </summary>
        </member>
        <member name="F:Stride.Importer.ThreeD.Material.MaterialStack.stack">
            <summary>
            The internal stack.
            </summary>
        </member>
        <member name="P:Stride.Importer.ThreeD.Material.MaterialStack.Count">
            <summary>
            Gets the size of the stack.
            </summary>
            <value>
            The size of the stack.
            </value>
        </member>
        <member name="P:Stride.Importer.ThreeD.Material.MaterialStack.IsEmpty">
            <summary>
            Gets a value indicating whether the stack is empty.
            </summary>
            <value>
              <c>true</c> if the stack is empty; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:Stride.Importer.ThreeD.Material.MaterialStack.Push(Stride.Importer.ThreeD.Material.StackElement)">
            <summary>
            Pushes the specified element.
            </summary>
            <param name="element">The element.</param>
        </member>
        <member name="M:Stride.Importer.ThreeD.Material.MaterialStack.Pop">
            <summary>
            Pops an element.
            </summary>
            <returns>The element.</returns>
        </member>
        <member name="M:Stride.Importer.ThreeD.Material.MaterialStack.Peek">
            <summary>
            Gets the top element of the stack.
            </summary>
            <returns>The top element of the stack.</returns>
        </member>
        <member name="M:Stride.Importer.ThreeD.Material.MaterialStack.Clear">
            <summary>
            Clears the stack.
            </summary>
        </member>
        <member name="T:Stride.Importer.ThreeD.Material.Operation">
            <summary>
            Enumeration of the different operations in the new Assimp's material stack.
            </summary>
        </member>
        <member name="T:Stride.Importer.ThreeD.Material.StackColor">
            <summary>
            Class representing a color in the new Assimp's material stack.
            </summary>
        </member>
        <member name="M:Stride.Importer.ThreeD.Material.StackColor.#ctor(Stride.Core.Mathematics.Color3,System.Single,System.Single,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Stride.Importer.ThreeD.Material.StackColor"/> class.
            </summary>
            <param name="color">The color of the node.</param>
            <param name="alpha">The alpha of the node.</param>
            <param name="blend">The blending coefficient of the node.</param>
            <param name="flags">The flags of the node.</param>
        </member>
        <member name="P:Stride.Importer.ThreeD.Material.StackColor.Color">
            <summary>
            Gets the color of the node.
            </summary>
            <value>
            The color of the node.
            </value>
        </member>
        <member name="T:Stride.Importer.ThreeD.Material.StackElement">
            <summary>
            Class representing an element in the new Assimp's material stack.
            </summary>
        </member>
        <member name="M:Stride.Importer.ThreeD.Material.StackElement.#ctor(System.Single,System.Single,System.Int32,Stride.Importer.ThreeD.Material.StackElementType)">
            <summary>
            Initializes a new instance of the <see cref="T:Stride.Importer.ThreeD.Material.StackElement"/> class.
            </summary>
            <param name="alpha">The alpha of the node.</param>
            <param name="blend">The blending coefficient of the node.</param>
            <param name="flags">The flags of the node.</param>
            <param name="type">The type of the node.</param>
        </member>
        <member name="P:Stride.Importer.ThreeD.Material.StackElement.Alpha">
            <summary>
            Gets the alpha of the node.
            </summary>
            <value>
            The alpha of the node.
            </value>
        </member>
        <member name="P:Stride.Importer.ThreeD.Material.StackElement.Blend">
            <summary>
            Gets the blending coefficient of the node.
            </summary>
            <value>
            The blending coefficient of the node.
            </value>
        </member>
        <member name="P:Stride.Importer.ThreeD.Material.StackElement.Flags">
            <summary>
            Gets the flags of the node.
            </summary>
            <value>
            The flags of the node.
            </value>
        </member>
        <member name="P:Stride.Importer.ThreeD.Material.StackElement.Type">
            <summary>
            Gets the type of the node.
            </summary>
            <value>
            The type of the node.
            </value>
        </member>
        <member name="T:Stride.Importer.ThreeD.Material.StackElementType">
            <summary>
            Enumeration of the different types of node in the new Assimp's material stack.
            </summary>
        </member>
        <member name="T:Stride.Importer.ThreeD.Material.StackOperation">
            <summary>
            Class representing an operation in the new Assimp's material stack.
            </summary>
        </member>
        <member name="M:Stride.Importer.ThreeD.Material.StackOperation.#ctor(Stride.Importer.ThreeD.Material.Operation,System.Single,System.Single,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Stride.Importer.ThreeD.Material.StackOperation"/> class.
            </summary>
            <param name="operation">The operation of the node.</param>
            <param name="alpha">The alpha of the node.</param>
            <param name="blend">The blending coefficient of the node.</param>
            <param name="flags">The flags.</param>
        </member>
        <member name="P:Stride.Importer.ThreeD.Material.StackOperation.Operation">
            <summary>
            Gets the operation of the node.
            </summary>
            <value>
            The operation of the node.
            </value>
        </member>
        <member name="T:Stride.Importer.ThreeD.Material.StackTexture">
            <summary>
            Class representing a texture in the new Assimp's material stack.
            </summary>
        </member>
        <member name="M:Stride.Importer.ThreeD.Material.StackTexture.#ctor(System.String,System.Int32,Stride.Importer.ThreeD.Material.MappingMode,Stride.Importer.ThreeD.Material.MappingMode,System.Single,System.Single,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Stride.Importer.ThreeD.Material.StackTexture"/> class.
            </summary>
            <param name="texturePath">The texture path.</param>
            <param name="channel">The uv channel used by the texture.</param>
            <param name="mappingModeU">The U mapping mode.</param>
            <param name="mappingModeV">The V mapping mode.</param>
            <param name="alpha">The alpha of the node.</param>
            <param name="blend">The blending coefficient of the node.</param>
            <param name="flags">The flags of the node.</param>
        </member>
        <member name="P:Stride.Importer.ThreeD.Material.StackTexture.TexturePath">
            <summary>
            Gets the texture path.
            </summary>
            <value>
            The texture path.
            </value>
        </member>
        <member name="P:Stride.Importer.ThreeD.Material.StackTexture.Channel">
            <summary>
            Gets the uv channel.
            </summary>
            <value>
            The uv channel.
            </value>
        </member>
        <member name="P:Stride.Importer.ThreeD.Material.StackTexture.MappingModeU">
            <summary>
            Gets the U mapping mode.
            </summary>
            <value>
            The U mapping mode.
            </value>
        </member>
        <member name="P:Stride.Importer.ThreeD.Material.StackTexture.MappingModeV">
            <summary>
            Gets the Vmapping mode.
            </summary>
            <value>
            The V mapping mode.
            </value>
        </member>
        <member name="M:Stride.Importer.ThreeD.MeshConverter.TryFindNodeIndexFromBone(Silk.NET.Assimp.Bone*,System.Collections.Generic.Dictionary{System.IntPtr,System.IntPtr},System.Collections.Generic.Dictionary{System.IntPtr,System.Int32},System.Int32@)">
            <summary>
            Returns true if <paramref name="nodeIndex"/> on <see cref="F:Stride.Importer.ThreeD.MeshConverter.nodes"/> corresponding to this <paramref name="bone"/> was found.
            </summary>
        </member>
        <member name="T:Stride.StrideVersion">
            <summary>
            Internal version used to identify Stride version.
            </summary>
            <remarks>
            During package build, PackageUpdateVersionTask is updating that file and expect some specific text regex so be careful if you change any of this.
            </remarks>
        </member>
        <member name="F:Stride.StrideVersion.PublicVersion">
            <summary>
            The version used by editor for display purpose. The 4th digit will automatically be replaced by the git height when building packages with Stride.Build.
            </summary>
        </member>
        <member name="F:Stride.StrideVersion.AssemblyVersion">
            <summary>
            The current assembly version as text, currently same as <see cref="F:Stride.StrideVersion.PublicVersion"/>.
            </summary>
        </member>
        <member name="F:Stride.StrideVersion.NuGetVersionSimple">
            <summary>
            The NuGet package version without special tags.
            </summary>
        </member>
        <member name="F:Stride.StrideVersion.NuGetVersion">
            <summary>
            The NuGet package version.
            </summary>
        </member>
        <member name="F:Stride.StrideVersion.NuGetVersionSuffix">
            <summary>
            The NuGet package suffix (i.e. -beta).
            </summary>
        </member>
        <member name="F:Stride.StrideVersion.BuildMetadata">
            <summary>
            The build metadata, usually +g[git_hash] during package. Automatically set by Stride.GitVersioning.GenerateVersionFile.
            </summary>
        </member>
        <member name="F:Stride.StrideVersion.AssemblyInformationalVersion">
            <summary>
            The informational assembly version, containing -beta01 or +g[git_hash] during package.
            </summary>
        </member>
        <member name="T:Stride.PublicKeys">
            <summary>
            Assembly signing information.
            </summary>
        </member>
        <member name="F:Stride.PublicKeys.Default">
            <summary>
            Assembly name suffix that contains signing information.
            </summary>
        </member>
    </members>
</doc>
